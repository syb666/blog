##  1 列举Http请求中常见的请求方式
##  2 谈谈你对HTTP协议的认识。1.1 长连接
##  3 简述MVC模式和MVT模式
##  4 简述Django请求生命周期
##  5 简述什么是FBV和CBV
##  6 谈一谈你对ORM的理解
##  7 rest_framework 认证组件的流程
##  8 什么是中间件并简述其作用
##  9 django 中间件生命周期
##  10 django中怎么写原生SQL
##  11 如何使用django orm批量创建数据
##  12 命令migrate 和makemigrations的差别
##  14 常用视图响应的方式是什么？
##  15 HTTP响应常见状态码分类
##  16 路由匹配原则是什么？
##  17 缓存系统类型有哪些
##  18 解决跨域的常用方式是什么？
##  19 信号的作用是什么？
##  20 Django的Model的继承有几种形式，分别是什么
##  21 Django中查询queryset时什么情况下用Q
##  22 Django中想验证表单提交是否格式正确需要用到Form中的哪个函数
##  23 orm如何取消级联
##  24 Django中如何读取和保存session，整个session的运行机制是什么
##  25 简述Django对http请求的执行流程
##  25 Django中当用户登录到A服务器进入登陆状态，下次被nginx代理到B服务器会出现什么影响
##  26 跨域请求Django是如何处理的
##  27 查询集的两大特性？什么是惰性执行
##  28 查询集返回的列表过滤器有哪些
##  29 如何获取django urlpatterns里面注册的所有url?
##  30 django路由系统中include是干嘛用的？
##  31 django2.0中的path与django1.xx里面的url有什么区别？
##  32 urlpatterns中的name与namespace有什么作用？你是如何使用的？
##  34 如何给一个字段设置一个主键？
##  35 如何设置一个带有枚举值的字典？
##  36 DateTimeField类型中的auto_now与auto_now_add有什么区别
##  37 values()与values_list()有什么区别？
##  38 selected_related与prefetch_related有什么区别？
##  39 当删除一个外键的时候，如何把与其关联的对应关系删除
##  40 class Meta中的元信息字段有哪些
##  41 多对多关联的表，如何插入数据？如何删除数据？如何更新数据？
##  42 django的M2M关系，如何手动生成第三张表？
##  43 在Django中，服务端给客户端响应信息有几种方式？分别是什么？
##  44 在视图函数中，常用的验证装饰器有哪些？
##  45 如何给一个视图函数加上缓存？
##  46 web框架的本质是什么？
##  47 创建Django工程、Django app、以及运行的命令
##  48 django中csrf的实现机制
##  49 Django App的目录结构
##  50 Django 获取用户前端请求数据的几种方式
##  51 描述下 自定义simple_tag
##  52 什么是Cookie、如何获取、设置Cookie
##  53 什么是session，与cookie的对比、设置、获取、清空session
##  54 什么是CSRF，及防范方式
##  55 get请求和post请求的区别
##  56 图书管理系统的表结构是怎么设计的？
##  57 WSGI / uwsgi/ uWSGI区分
##  59 解释blank和null
##  60 QueryDict和dict区别
##  61 谈谈你对restful规范的认识？
##  62 Django 本身提供了 runserver，为什么不能用来部署？  
##  63 Tornado 的核是什么？ 
##  64  Django重定向你是如何实现的？用的什么状态码？  
##  65 Django中如何加载初始化数据  
##  66 简述Django下的（内建）缓存机制


##  1 列举Http请求中常见的请求方式
HTTP请求的方法：
HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式
 

* 注意：
  * 1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。
  * 2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。
                 
* GET
  * 向特定的路径资源发出请求
  * 注意：GET方法不应当被用于产生“副作用”的操作中，例如在WebApplication中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url
      
* POST
  * 向指定路径资源提交数据进行处理请求（一般用于提交表单或者上传文件）
  * 数据被包含在请求体中，POST请求可能会导致新的资源的建立和/或已有资源的修改。Loadrunner中对应POST请求函数：web_submit_data,web_submit_form
                   
* OPTIONS
  * 返回服务器针对特定资源所支持的HTTP请求方法
  * 允许客户端查看服务器的性能，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性
     
* HEAD
  * 向服务器索与GET请求相一致的响应，只不过响应体将不会被返回
  * 这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
     
* PUT
  * 从客户端向服务器传送的数据取代指定的文档的内容
      
* DELETE
  * 请求服务器删除指定的页面
     
* TRACE
  * 回回显服务器收到的请求，主要用于测试或诊断
    
* CONNECT
  * HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务


## 2 谈谈你对HTTP协议的认识。1.1 长连接
HTTP是一个属于应用层的面向对象的协议</br>
HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</br>
Web服务器根据接收到的请求后，向客户端发送响应信息。<br>
* 基于TCP/IP
双方建立通信的顺序,以及Web页面显示需要 处理的步骤,等等。像这样把与互联网相关联的协议集合起来总称为TCP/IP。
而http协议是基于TCP/IP协议之上的应用层协议。
* 基于请求－响应模式
HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回
* 无状态保存
HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。
也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。

 使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。
 这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,
 因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,
 也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是
 无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。

##  3 简述MVC模式和MVT模式
  所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层,他们之间以一种插件式的、松耦合的方式连接在一起，
模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求

图一

  Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值：
* M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。
* T 代表模板 (Template)：负责如何把页面展示给用户(html)。
* V 代表视图（View）： 负责业务逻辑，并在适当时候调用Model和Template。</br>
  除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，
View再调用相应的Model和Template，MTV的响应模式如下所示：
  
图二

一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，
（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，
然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。


##  4 简述Django请求生命周期
一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，
那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，
视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。
* 1.wsgi,请求封装后交给web框架 （Flask、Django）     
* 2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session - 
* 3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数    
* 4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates => 渲染 - 
* 5.中间件，对响应的数据进行处理。 
* 6.wsgi,将响应的内容发送给浏览器。


图三

## 5 简述什么是FBV和CBV
* FBV（function base views）就是在视图里面使用函数处理请求
* CBV（class base views）就是在视图里面使用类处理请求

## 6 谈一谈你对ORM的理解
ORM是“对象-关系-映射”的简称。
MVC或者MVT框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，
通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动

## 7 rest_framework 认证组件的流程
认证组件 写一个类并注册到认证类(authentication_classes)，在类的的authticate方法中编写认证逻辑代码

## 8 什么是中间件并简述其作用
中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。
每个中间件组件都负责做一些特定的功能。中间件是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变django的输入与输出。


## 9 django 中间件生命周期

图四

请求过来：
中间件：拦截一部分请求；比如验证session, 没有登录的 请求一些页面，跳转至登录页；(图片为中间件的请求过程.)再到 urls ，
分发请求到views 视图 ，通过 CBV(dispatch反射) 和 FBV 的 get 请求 讲 template 页面渲染返回给用户；渲染之前 可以从数据库拿出数据，
放到render 的参数里面传递过去， locals() 表示 把所有参数传递还可以 实例化 其他 form 类，并渲染给前端









